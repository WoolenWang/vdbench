package Vdb;

/*
 * Copyright 2010 Sun Microsystems, Inc. All rights reserved.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * The contents of this file are subject to the terms of the Common
 * Development and Distribution License("CDDL") (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the License at http://www.sun.com/cddl/cddl.html
 * or ../vdbench/license.txt. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * When distributing the software, include this License Header Notice
 * in each file and include the License file at ../vdbench/licensev1.0.txt.
 *
 * If applicable, add the following below the License Header, with the
 * fields enclosed by brackets [] replaced by your own identifying information:
 * "Portions Copyrighted [year] [name of copyright owner]"
 */


/*
 * Author: Henk Vandenbergh.
 */

import java.util.Vector;
import java.io.*;
import Utils.*;

/**
 * Kstat related functionality
 */
public class NfsStats
{
  private final static String c = "Copyright (c) 2010 Sun Microsystems, Inc. " +
                                  "All Rights Reserved. Use is subject to license terms.";

  private static NfsV3 nfs3_old   = new NfsV3();
  private static NfsV3 nfs3_new   = new NfsV3();
  private static NfsV3 nfs3_delta = new NfsV3();

  private static NfsV4 nfs4_old   = new NfsV4();
  private static NfsV4 nfs4_new   = new NfsV4();
  private static NfsV4 nfs4_delta = new NfsV4();

  private static long  kstat_ctl_t = 0;

  private static boolean nfs_reports_needed = false;

  public static String warning =
  "\n\nBe very clearly aware that this report shows nfsstat data for ALL \n" +
  "NFS mounted file systems on your system, and not only your test files.\n" +
  "If your Vdbench output directory is on an NFS mounted directory       \n" +
  "NFS activity generated by Vdbench reporting is also included.         \n" +
  "If you don't want Vdbench reporting included, specify a Vdbench       \n" +
  "output directory that does not use NFS.                             \n\n";



  public static void setNfsReportsNeeded(boolean bool)
  {
    nfs_reports_needed = bool;
  }
  public static boolean areNfsReportsNeeded()
  {
    return nfs_reports_needed;
  }

  /**
   * Obtain kstat statistics for all three NFS versions.
   */
  public static void getAllNfsDeltasFromKstat()
  {
    String data;
    long tod = Native.get_simple_tod();

    if (kstat_ctl_t == 0)
    {
      /* Create Kstat structures: */
      kstat_ctl_t = NamedKstat.kstat_open();

      /* Check to see if we can get data: */
      data = NamedKstat.kstat_lookup_stuff(kstat_ctl_t, "nfs", "rfsreqcnt_v3");
      if (data.startsWith("JNI"))
      {
        common.ptod("getAllNfsStats(): no data found for nfs version3");
        nfs3_delta = null;
      }

      data = NamedKstat.kstat_lookup_stuff(kstat_ctl_t, "nfs", "rfsreqcnt_v4");
      if (data.startsWith("JNI"))
      {
        common.ptod("getAllNfsStats(): no data found for nfs version4");
        nfs4_delta = null;
      }

    }

    if (nfs3_delta != null)
    {
      data = NamedKstat.kstat_lookup_stuff(kstat_ctl_t, "nfs", "rfsreqcnt_v3");
      nfs3_new = new NfsV3();
      nfs3_new.parseNamedData(data);
      nfs3_new.setTime(tod);
    }

    if (nfs4_delta != null)
    {
      data = NamedKstat.kstat_lookup_stuff(kstat_ctl_t, "nfs", "rfsreqcnt_v4");
      nfs4_new = new NfsV4();
      nfs4_new.parseNamedData(data);
      nfs4_new.setTime(tod);
    }

    allDelta();
    newToOld();

    //common.ptod("nfs3_delta.getTotal(): " + nfs3_delta.getTotal());
  }

  public static void newToOld()
  {
    nfs3_old = nfs3_new;
    nfs4_old = nfs4_new;
  }

  public static void allDelta()
  {
    if (nfs3_delta != null) nfs3_delta.delta(nfs3_new, nfs3_old);
    if (nfs4_delta != null) nfs4_delta.delta(nfs4_new, nfs4_old);
  }


  /**
   * Open NFS reports
   */
  public static void createNfsReports()
  {
    /* Look at all hosts: */
    for (int i = 0; i < Host.getDefinedHosts().size(); i++)
    {
      Host host = (Host) Host.getDefinedHosts().elementAt(i);
      if (host.getHostInfo() != null)
        host.createNfsReports();
    }
  }

  /**
   * Create reporting layout for one NFS type.
   */
  public static reporting[] nfsLayout(NamedData   nameddata,
                                      Object      owner)
  {
    String[] titles = nameddata.getFieldTitles();

    /* Allocate an array for headers. */
    /* This includes one extra for 'interval', and one last one for 'null=end': */
    reporting[] rep = new reporting[titles.length + 2];

    rep[0] = new reporting("interval", "", "%*s", 8);

    for (int i = 0; i < titles.length; i++)
    {
      String title = titles[i];
      int width = Math.max(5, title.length());
      rep[i+1] = new reporting(title, "rate", "%*.1F", width);
    }

    return rep;
  }



  public static void PrintAllNfs(String title)
  {
    for (int i = 0; i < Host.getDefinedHosts().size(); i++)
    {
      Host host = (Host) Host.getDefinedHosts().elementAt(i);
      if (host.getHostInfo() != null)
        host.PrintNfsstatInterval(title);
    }
  }


  public static void NfsPrint(Report      report,
                              NamedData   nameddata,
                              reporting[] rep,
                              String      title,
                              Object      owner)
  {
    StringBuffer buf = new StringBuffer(256);

    buf.append(rep[0].report( title));

    String[] labels = nameddata.getFieldTitles();

    for (int i = 0; i < labels.length; i++)
    {
      buf.append(rep[i+1].report(nameddata.getRate(i)));
    }

    report.println(common.tod() + buf.toString());
  }



  public static NfsV3 getNfs3()
  {
    return nfs3_delta;
  }
  public static NfsV4 getNfs4()
  {
    return nfs4_delta;
  }
}



